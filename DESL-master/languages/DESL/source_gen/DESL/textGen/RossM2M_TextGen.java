package DESL.textGen;

/*Generated by MPS */

import jetbrains.mps.text.rt.TextGenDescriptorBase;
import jetbrains.mps.text.rt.TextGenContext;
import jetbrains.mps.text.impl.TextGenSupport;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Objects;
import com.mbeddr.core.modules.behavior.ITypeDeclaration__BehaviorDescriptor;
import jetbrains.mps.lang.traceable.behavior.UnitConcept__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class RossM2M_TextGen extends TextGenDescriptorBase {
  @Override
  public void generateText(final TextGenContext ctx) {
    final TextGenSupport tgs = new TextGenSupport(ctx);
    tgs.createUnitInfo();
    // headers
    List<String> headers = ListSequence.fromList(new ArrayList<String>());
    tgs.append("#include <ross.h>");
    tgs.newLine();
    ListSequence.fromList(headers).addElement("ross");
    Headers.headers(ctx.getPrimaryInput(), headers, ctx);

    // events
    for (SNode event : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(ctx.getPrimaryInput(), LINKS.events$uflG), CONCEPTS.EventDefinition$wO))) {
      if (!(SPropertyOperations.getString(SLinkOperations.getTarget(event, LINKS.eventType$MGmZ), PROPS.name$MnvL).equals("LP_INIT")) && !(SPropertyOperations.getString(SLinkOperations.getTarget(event, LINKS.eventType$MGmZ), PROPS.name$MnvL).equals("INIT")) && !(SPropertyOperations.getString(SLinkOperations.getTarget(event, LINKS.eventType$MGmZ), PROPS.name$MnvL).equals("LP_FINI")) && !(SPropertyOperations.getString(SLinkOperations.getTarget(event, LINKS.eventType$MGmZ), PROPS.name$MnvL).equals("FINI"))) {
        tgs.append("#define ");
        tgs.append(SPropertyOperations.getString(SLinkOperations.getTarget(event, LINKS.eventType$MGmZ), PROPS.name$MnvL));
        tgs.append(" ");
        tgs.append(String.valueOf(1 + SNodeOperations.getIndexInParent(event)));
        tgs.newLine();
      }
    }
    tgs.newLine();

    // macros
    Macros.macros(ctx.getPrimaryInput(), ctx);

    // typedefs
    tgs.append("typedef double simtime_t;");
    tgs.newLine();
    tgs.append("typedef unsigned long lp_id_t;");
    tgs.newLine();
    tgs.newLine();

    long total_lps = 0;
    for (SNode processAllocation : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(ctx.getPrimaryInput(), LINKS.processAllocations$cuUJ), CONCEPTS.ProcessAllocation$5Z))) {
      total_lps += (SPropertyOperations.getInteger(SNodeOperations.cast(SLinkOperations.getTarget(processAllocation, LINKS.processes$hZqx), CONCEPTS.ProcessArray$Ux), PROPS.right$2uAQ) - SPropertyOperations.getInteger(SNodeOperations.cast(SLinkOperations.getTarget(processAllocation, LINKS.processes$hZqx), CONCEPTS.ProcessArray$Ux), PROPS.left$2u8O) + 1);
    }

    tgs.append("unsigned total_lps = ");
    tgs.append(String.valueOf(total_lps));
    tgs.append(";");
    tgs.newLine();
    tgs.newLine();

    // state structs
    StateStructs.stateStructs(ctx.getPrimaryInput(), ctx);

    // structs
    Structs.structs(ctx.getPrimaryInput(), ctx);

    // checkpoint struct
    tgs.append("struct checkpoint {");
    tgs.newLine();
    ctx.getBuffer().area().increaseIndent();

    if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("pcs")) {
      tgs.indent();
      tgs.append("int32_t channel_to_reallocate;");
      tgs.newLine();
      tgs.indent();
      tgs.append("int32_t channel_to_free;");
      tgs.newLine();
      tgs.indent();
      tgs.append("struct lp_state_type state;");
      tgs.newLine();
    } else if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("phold")) {
      tgs.indent();
      tgs.append("struct phold_state state;");
      tgs.newLine();
    }

    ctx.getBuffer().area().decreaseIndent();
    tgs.append("};");
    tgs.newLine();
    tgs.newLine();

    /*
      events enum and message struct, foreach class
      (ROSS requires the event type to be explicit in the received message, 
      in order to handle different event types) 

    */

    tgs.append("typedef enum {");
    tgs.newLine();
    for (SNode event : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(ctx.getPrimaryInput(), LINKS.events$uflG), CONCEPTS.EventDefinition$wO))) {
      ctx.getBuffer().area().increaseIndent();
      if (SPropertyOperations.getString(SLinkOperations.getTarget(event, LINKS.eventType$MGmZ), PROPS.name$MnvL) != "INIT" || SPropertyOperations.getString(SLinkOperations.getTarget(event, LINKS.eventType$MGmZ), PROPS.name$MnvL) != "LP_INIT") {
        tgs.indent();
        tgs.append("event_");
        tgs.append(SPropertyOperations.getString(SLinkOperations.getTarget(event, LINKS.eventType$MGmZ), PROPS.name$MnvL));
        tgs.append(",");
        tgs.newLine();
      }
      ctx.getBuffer().area().decreaseIndent();
    }
    tgs.append("} ");
    tgs.append(SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL));
    tgs.append("_EVENT_TYPE;");
    tgs.newLine();
    tgs.newLine();

    tgs.append("struct ");
    tgs.append(SPropertyOperations.getString(SLinkOperations.getTarget(ctx.getPrimaryInput(), LINKS.messageStruct$xVlJ), PROPS.name$MnvL));
    tgs.append(" {");
    tgs.newLine();
    ctx.getBuffer().area().increaseIndent();
    tgs.indent();
    tgs.append(SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL));
    tgs.append("_EVENT_TYPE event_type;");
    tgs.newLine();
    tgs.indent();
    tgs.append("struct checkpoint cp;");
    tgs.newLine();
    for (SNode member : ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(ctx.getPrimaryInput(), LINKS.messageStruct$xVlJ), LINKS.members$C59R))) {
      tgs.indent();
      tgs.appendNode(member);
    }
    ctx.getBuffer().area().decreaseIndent();
    tgs.append("};");
    tgs.newLine();
    tgs.newLine();


    // global variables
    Configuration.configuration(ctx.getPrimaryInput(), ctx);

    // custom allocator (to make malloc reversible)
    if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("pcs")) {
      tgs.append("typedef struct {\n    struct channel channel_pool[pcs_CHANNELS_PER_CELL];\n    struct sir_data_per_cell sir_data_pool[pcs_CHANNELS_PER_CELL];\n    bool channel_used[pcs_CHANNELS_PER_CELL];\n} channel_allocator_t;\n\nstatic channel_allocator_t **allocators;\n");
      tgs.newLine();
      tgs.append("void init_allocators(uint32_t num) {\n    allocators = malloc(num * sizeof(channel_allocator_t *));\n    if(allocators == NULL) {\n        perror(\"Unable to initialize channel allocators\");\n        abort();\n    }\n    for (uint32_t i = 0; i < num; i++) {\n        allocators[i] = malloc(sizeof(channel_allocator_t));\n        if(allocators[i] == NULL) {\n            printf(\"Unable to initialize channel allocator %d\", i);\n            perror(\"\");\n            abort();\n        }\n        memset(allocators[i], 0, sizeof(channel_allocator_t));\n        for (int j = 0; j < pcs_CHANNELS_PER_CELL; j++) {\n            allocators[i]->channel_used[j] = false;\n        }\n    }\n}\n");
      tgs.newLine();
      tgs.append("void destroy_allocators() {\n    for (uint32_t i = 0; i < total_lps; i++) {\n        free(allocators[i]);\n    }\n    free(allocators);\n}\n");
      tgs.newLine();
      tgs.append("struct channel *allocate_channel(lp_id_t lp, int32_t id) {\n    if (id < 0 || id >= pcs_CHANNELS_PER_CELL) return NULL;\n    channel_allocator_t *allocator = allocators[lp];\n    if (!allocator->channel_used[id]) {\n        allocator->channel_used[id] = true;\n        return &allocator->channel_pool[id];\n    }\n\n    printf(\"Could not allocate channel %d for lp %lu\", id, lp);\n    abort();\n}\n");
      tgs.newLine();
      tgs.append("struct sir_data_per_cell *allocate_sir_data(lp_id_t lp, int32_t id) {\n   channel_allocator_t *allocator = allocators[lp];\n   return &allocator->sir_data_pool[id];\n}\n");
      tgs.newLine();
      tgs.append("void deallocate_channel(lp_id_t lp, struct channel *c) {\n\n    channel_allocator_t *allocator = allocators[lp];\n    int id = c->channel_id;\n    if (id >= 0 && id < pcs_CHANNELS_PER_CELL) {\n        allocator->channel_used[id] = false;\n#ifdef DEBUG\n        printf(\"deallocate_channel: Deallocated channel %d for lp %lu\", c->channel_id, lp);\n        puts(\"\");\n#endif\n    } else {\n        printf(\"LP %lu trying to deallocate an invalid channel %d.\", lp, c->channel_id);\n        abort();\n    }\n}\n");
      tgs.newLine();
      tgs.append("int32_t get_channel_id(lp_id_t lp, struct channel *c) {\n    channel_allocator_t *allocator = allocators[lp];\n    for (int i = 0; i < pcs_CHANNELS_PER_CELL; i++) {\n        if (&allocator->channel_pool[i] == c) {\n            return i;\n        }\n    }\n    return -1; // Not found\n}\n");
      tgs.newLine();
      tgs.append("struct channel *get_channel(lp_id_t lp, int32_t index) {\n    channel_allocator_t *allocator = allocators[lp];\n    return &allocator->channel_pool[index];\n}\n");
      tgs.newLine();
    }

    // custom mapping (LPs are evenly distributed among PEs, the leftovers are assigned to the first PE)
    tgs.append("tw_peid custom_mapping_lp_to_pe(tw_lpid gid)\n{\n    tw_lpid ret;\n    unsigned min_num_lps_per_pe = total_lps / tw_nnodes();\n    unsigned extra_lps = total_lps % tw_nnodes();\n\n    if (gid < min_num_lps_per_pe + extra_lps)\n        ret = 0;\n    else\n        ret = (gid - extra_lps) / min_num_lps_per_pe;\n#ifdef DEBUG\n    printf(\"LP with GID %lu mapped on node %lu\", gid, ret);\n    puts(\"\");\n#endif\n\n    return ret;\n}\n");
    tgs.newLine();
    tgs.append("tw_lp *custom_mapping_lpgid_to_local(tw_lpid gid)\n{\n    tw_lpid ret;\n    unsigned min_num_lps_per_pe = total_lps / tw_nnodes();\n    unsigned extra_lps = total_lps % tw_nnodes();\n\n    if (gid < min_num_lps_per_pe + extra_lps) {\n        ret = gid;\n    } else {\n        ret = (gid - extra_lps) % min_num_lps_per_pe;\n    }\n\n#ifdef DEBUG\n    printf(\"[%lu] LP with GID %lu mapped on LID %lu\", g_tw_mynode, gid, ret);\n    puts(\"\");\n#endif\n\n    return g_tw_lp[ret];\n}\n");
    tgs.newLine();
    tgs.append("void custom_mapping_setup(void)\n{\n    int lpid;\n    unsigned long gid;\n\n    // set up KPs\n    for (int kpid = 0; kpid < g_tw_nkp; kpid++)\n        tw_kp_onpe(kpid, g_tw_pe);\n\n    // figure out how many LPs are on this PE\n    unsigned min_num_lps_per_pe = total_lps/tw_nnodes();\n    unsigned extra_lps = total_lps - (min_num_lps_per_pe * tw_nnodes());\n    unsigned lps_on_pe = min_num_lps_per_pe;\n    if (g_tw_mynode == 0) {\n        lps_on_pe += extra_lps;\n    }\n\n    // set up the LPs\n    for (lpid = 0; lpid < lps_on_pe; lpid++) {\n\n        gid = g_tw_mynode * min_num_lps_per_pe + lpid + extra_lps * (g_tw_mynode != 0);\n#ifdef DEBUG\n        printf(\"[%lu] Setting up mapping: LP %d to GID %lu\", g_tw_mynode, lpid, gid);\n        puts(\"\");\n#endif\n        // map LP to KP\n        tw_lp_onpe(lpid, g_tw_pe, gid);\n        tw_lp_onkp(g_tw_lp[lpid], g_tw_kp[lpid % g_tw_nkp]);\n    }\n}\n");
    tgs.newLine();

    // external functions definition

    boolean containsContext;
    for (SNode function : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(ctx.getPrimaryInput(), LINKS.externalFunctions$LqEg), CONCEPTS.ExternalFunction$U_))) {
      //  if the function uses an API from the rand library, add a tw_lp *lp parameter to its signature
      if (ListSequence.fromList(SNodeOperations.getNodeDescendants(function, CONCEPTS.Expent$Yu, false, new SAbstractConcept[]{})).isNotEmpty() || ListSequence.fromList(SNodeOperations.getNodeDescendants(function, CONCEPTS.Random$XZ, false, new SAbstractConcept[]{})).isNotEmpty()) {
        tgs.appendNode(SLinkOperations.getTarget(function, LINKS.type$sXU3));
        tgs.append(" ");
        tgs.append(SPropertyOperations.getString(function, PROPS.name$MnvL));
        tgs.append("(");
        containsContext = false;
        for (SNode arg : ListSequence.fromList(SLinkOperations.getChildren(function, LINKS.arguments$6da0))) {
          if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(arg, LINKS.type$sXU3), CONCEPTS.RngType$1E)) {
            containsContext = true;
          }
          tgs.appendNode(arg);
          if (SNodeOperations.getIndexInParent(arg) == ListSequence.fromList(SLinkOperations.getChildren(function, LINKS.arguments$6da0)).count() - 1 && containsContext) {
            tgs.append(")");
            tgs.newLine();
          } else {
            tgs.append(", ");
          }
        }
        if (!(containsContext)) {
          tgs.append("tw_lp *lp)");
          tgs.newLine();
        }
        tgs.appendNode(SLinkOperations.getTarget(function, LINKS.body$1GE0));
        tgs.newLine();
      } else {
        tgs.appendNode(function);
        tgs.newLine();
      }
    }


    if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("phold")) {
      tgs.append("void __attribute__ ((noinline)) busy_loop(unsigned long long max) {\n    for (unsigned long long i = 0; i < max; i++) {\n        __asm__ volatile(\"pause\" : \"+g\" (i) : :);\n    }\n}\n");
      tgs.newLine();
    }


    // allocation_by_index (PCS)
    if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("pcs")) {
      tgs.append("static void allocation_by_index(struct lp_state_type *pointer, int index, tw_lp *lp)\n{\n    double summ;\n\n    pcs_SET_CHANNEL(pointer, index);\n\n    struct channel *c = allocate_channel(custom_mapping_lpgid_to_local(pointer->me)->id, index);\n    list_insert_tail(pointer->channels, c);\n\n\n    summ = 0.0;\n\n    __typeof(list_head(pointer->channels)) ch = list_head(pointer->channels);\n    while(ch != NULL) {\n        ch->sir_data->fading = tw_rand_exponential(lp->rng, 1.0);\n        summ += generate_cross_path_gain(lp->rng) * ch->sir_data->power * ch->sir_data->fading;\n        ch = list_next(ch);\n    }\n\n    assert(c != NULL);\n\n    if (fabs(summ) < DBL_EPSILON)\n    {\n        c->sir_data->power = pcs_MIN_POWER;\n    }\n    else\n    {\n        c->sir_data->fading = tw_rand_exponential(lp->rng, 1.0);\n        c->sir_data->power = ((pcs_SIR_AIM * summ) / (generate_path_gain(lp->rng) * c->sir_data->fading));\n        if (c->sir_data->power < pcs_MIN_POWER)\n        {\n            c->sir_data->power = pcs_MIN_POWER;\n        }\n        if (c->sir_data->power > pcs_MAX_POWER)\n        {\n            c->sir_data->power = pcs_MAX_POWER;\n        }\n    }\n}\n");
      tgs.newLine();
      tgs.newLine();
      tgs.newLine();
    }

    // restore state function
    // todo the following function is (vergognosamente) application-specific
    if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("pcs")) {
      tgs.append("void RESTORE_STATE(struct lp_state_type *state, struct event_content_type *msg, tw_lp *lp)\n{\n    struct checkpoint *cp = &msg->cp;\n    *state = cp->state;\n\n    if (cp->channel_to_reallocate != -1) {\n        allocation_by_index(state, cp->channel_to_reallocate, lp);\n    }\n    if (cp->channel_to_free != -1) {\n\n        __typeof(list_head(state->channels)) ch = list_head(state->channels);\n        while(ch != NULL) {\n            tw_rand_reverse_unif(lp->rng);\n            ch = list_next(ch);\n        }\n\n        deallocation(state->me, state, cp->channel_to_free, 0);\n\n        double summ = 0.0;\n\n        ch = list_head(state->channels);\n        while(ch != NULL) {\n            ch->sir_data->fading = tw_rand_exponential(lp->rng, 1.0);\n            summ += generate_cross_path_gain(lp->rng) * ch->sir_data->power * ch->sir_data->fading;\n            ch = list_next(ch);\n        }\n\n        ch = list_head(state->channels);\n        while (ch != NULL) {\n            if (fabs(summ) < DBL_EPSILON)\n            {\n                ch->sir_data->power = pcs_MIN_POWER;\n            }\n            else\n            {\n                ch->sir_data->fading = tw_rand_exponential(lp->rng, 1.0);\n                ch->sir_data->power = ((pcs_SIR_AIM * summ) / (generate_path_gain(lp->rng) * ch->sir_data->fading));\n                if (ch->sir_data->power < pcs_MIN_POWER)\n                {\n                    ch->sir_data->power = pcs_MIN_POWER;\n                }\n                if (ch->sir_data->power > pcs_MAX_POWER)\n                {\n                    ch->sir_data->power = pcs_MAX_POWER;\n                }\n            }\n\n            ch = list_next(ch);\n        }\n    }\n\n\n    switch (msg->event_type) {\n        case event_START_CALL:\n            tw_rand_reverse_unif(lp->rng);\n            /* fall through */\n        case event_HANDOFF_RECV:\n            tw_rand_reverse_unif(lp->rng);\n            break;\n        case event_END_CALL:\n        case event_LP_INIT:\n        case event_HANDOFF_LEAVE:\n            break;\n        case event_FADING_RECHECK: {\n            __typeof(list_head(state->channels)) ch = list_head(state->channels);\n            while(ch != NULL) {\n                tw_rand_reverse_unif(lp->rng);\n                ch = list_next(ch);\n            }\n            break;\n        }\n    }\n\n}");
      tgs.newLine();
    } else if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("phold")) {
      tgs.append("void RESTORE_STATE(struct phold_state *state, struct phold_message *msg, tw_lp *lp)\n{\n    struct checkpoint *cp = &msg->cp;\n    *state = cp->state;\n\n    if (msg->event_type == event_EVENT) {\n\ttw_rand_reverse_unif(lp->rng);\n    }\n}\n");
      tgs.newLine();
    }

    tgs.newLine();


    for (final SNode c : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(ctx.getPrimaryInput(), LINKS.classes$SNAM), CONCEPTS.ClassDefinition$NR))) {

      // init function ( {node.name}_{class.name}_init(...) )

      SNode initHandler = Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(c, LINKS.handlers$Nr2P), CONCEPTS.EventHandler$Ov)).findFirst((it) -> SPropertyOperations.getString(it, PROPS.eventName$AHdn).equals("INIT") || SPropertyOperations.getString(it, PROPS.eventName$AHdn).equals("LP_INIT"));

      SNode stateArgumentInit = Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(SLinkOperations.getTarget(initHandler, LINKS.function$5bPH), LINKS.arguments$6da0), CONCEPTS.Argument$9m)).findFirst((it) -> SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, LINKS.type$sXU3), CONCEPTS.PointerType$HX) && Objects.equals(SNodeOperations.getConcept(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, LINKS.type$sXU3), CONCEPTS.PointerType$HX), LINKS.baseType$zMGV)), SNodeOperations.getConcept(ITypeDeclaration__BehaviorDescriptor.createType_id3o2OLGv7CoR.invoke(SLinkOperations.getTarget(c, LINKS.stateStruct$NqNO)))));
      tgs.append("void ");
      tgs.append(SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL));
      tgs.append("_");
      tgs.append(SPropertyOperations.getString(c, PROPS.name$MnvL));
      tgs.append("_init(");
      tgs.appendNode(stateArgumentInit);
      tgs.append(", tw_lp *lp)");
      tgs.newLine();

      // append the function's statements, creating the "me" and "now" variables at the beginning, mocking the "me" and "now" parameters in SimpleDES handlers
      tgs.append("{");
      tgs.newLine();
      ctx.getBuffer().area().increaseIndent();
      tgs.indent();
      tgs.append("tw_lpid me = lp->gid;");
      tgs.newLine();
      tgs.indent();
      tgs.append("double now = 0;");
      tgs.newLine();
      for (SNode statement : ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(SLinkOperations.getTarget(initHandler, LINKS.function$5bPH), LINKS.body$1GE0), LINKS.statements$euTV))) {
        tgs.indent();
        tgs.appendNode(statement);
        tgs.newLine();
      }
      ctx.getBuffer().area().decreaseIndent();
      tgs.append("}");
      tgs.newLine();

      /*
        determine if a pre_run handler must be defined (i.e., if the INIT event handler
        includes a SendEvent statement with receiver != me) 

      */

      SNode sendToSomeoneElse = Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(SLinkOperations.getTarget(SLinkOperations.getTarget(initHandler, LINKS.function$5bPH), LINKS.body$1GE0), LINKS.statements$euTV), CONCEPTS.SendEvent$u)).where((it) -> SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, LINKS.to$WtFs), CONCEPTS.ArgumentRef$iE) && SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, LINKS.to$WtFs), CONCEPTS.ArgumentRef$iE), LINKS.arg$WIp5), PROPS.name$MnvL) == "me").first();

      if ((sendToSomeoneElse != null)) {
        // todo pre_run handler (all the message definition statements should be moved from the INIT handler to the pre_run handler as well), maybe it would be simpler not to let the user send events to other LPs in the INIT handler
      }
      tgs.newLine();

      // generic event handler ( {node.name}_{node.class}_event(...) )
      tgs.append("void ");
      tgs.append(SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL));
      tgs.append("_");
      tgs.append(SPropertyOperations.getString(c, PROPS.name$MnvL));
      tgs.append("_event(");
      tgs.appendNode(ITypeDeclaration__BehaviorDescriptor.createType_id3o2OLGv7CoR.invoke(SLinkOperations.getTarget(c, LINKS.stateStruct$NqNO)));
      tgs.append(" *state, tw_bf *bf, ");
      tgs.appendNode(ITypeDeclaration__BehaviorDescriptor.createType_id3o2OLGv7CoR.invoke(SLinkOperations.getTarget(ctx.getPrimaryInput(), LINKS.messageStruct$xVlJ)));
      tgs.append(" *content, tw_lp *lp)");
      tgs.newLine();
      tgs.append("{");
      tgs.newLine();
      ctx.getBuffer().area().increaseIndent();

      // create "me" and "now" variables
      tgs.indent();
      tgs.append("tw_lpid me = lp->gid;");
      tgs.newLine();
      tgs.indent();
      tgs.append("double now = 0;");
      tgs.newLine();

      // struct checkpoint instantiation
      tgs.indent();
      tgs.append("struct checkpoint cp = {");
      tgs.newLine();
      if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("pcs")) {
        ctx.getBuffer().area().increaseIndent();
        tgs.indent();
        tgs.append(".state = *state,");
        tgs.newLine();
        tgs.indent();
        tgs.append(".channel_to_free = -1,");
        tgs.newLine();
        tgs.indent();
        tgs.append(".channel_to_reallocate = -1,");
        tgs.newLine();
        ctx.getBuffer().area().decreaseIndent();
      } else if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("phold")) {
        tgs.indent();
        tgs.append(".state = *state,");
        tgs.newLine();
      }
      tgs.indent();
      tgs.append("};");
      tgs.newLine();

      tgs.indent();
      tgs.append("content->cp = cp;");
      tgs.newLine();

      tgs.indent();
      tgs.append("switch(content->event_type) {");
      tgs.newLine();
      ctx.getBuffer().area().increaseIndent();
      for (SNode handler : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(c, LINKS.handlers$Nr2P), CONCEPTS.EventHandler$Ov))) {
        if (!(SPropertyOperations.getString(handler, PROPS.eventName$AHdn).equals("INIT")) && !(SPropertyOperations.getString(handler, PROPS.eventName$AHdn).equals("LP_INIT"))) {
          tgs.newLine();
          tgs.indent();
          tgs.append("case event_");
          tgs.append(SPropertyOperations.getString(handler, PROPS.eventName$AHdn));
          tgs.append(":");
          tgs.newLine();
          ctx.getBuffer().area().increaseIndent();
          for (SNode statement : ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(SLinkOperations.getTarget(handler, LINKS.function$5bPH), LINKS.body$1GE0), LINKS.statements$euTV))) {
            tgs.indent();
            tgs.appendNode(statement);
            tgs.newLine();
            UpdateCheckpoint.UpdateCheckpoint(statement, ctx);
          }
          tgs.indent();
          tgs.append("break;");
          tgs.newLine();
          ctx.getBuffer().area().decreaseIndent();
        }
      }

      tgs.newLine();
      tgs.indent();
      tgs.append("default:");
      tgs.newLine();
      ctx.getBuffer().area().increaseIndent();
      tgs.indent();
      tgs.append("fprintf(stderr, \"Unknown event type! (event type = %d)\", content->event_type);");
      tgs.newLine();
      tgs.indent();
      tgs.append("abort();");
      tgs.newLine();
      ctx.getBuffer().area().decreaseIndent();
      ctx.getBuffer().area().decreaseIndent();
      tgs.indent();
      tgs.append("}");
      tgs.newLine();
      ctx.getBuffer().area().decreaseIndent();
      tgs.append("}");
      tgs.newLine();
      tgs.newLine();

      // finalize function ( {node.name}_{node.class}_final(...) )
      // todo it needs to be at least defined, tbd if it's useful
      tgs.append("void ");
      tgs.append(SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL));
      tgs.append("_");
      tgs.append(SPropertyOperations.getString(c, PROPS.name$MnvL));
      tgs.append("_final(");
      tgs.appendNode(ITypeDeclaration__BehaviorDescriptor.createType_id3o2OLGv7CoR.invoke(SLinkOperations.getTarget(c, LINKS.stateStruct$NqNO)));
      tgs.append(" *s, tw_lp *lp) {}");
      tgs.newLine();

      tgs.newLine();
    }


    // enum lpTypes (classes)
    tgs.append("typedef enum {");
    tgs.newLine();
    ctx.getBuffer().area().increaseIndent();
    for (SNode c : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(ctx.getPrimaryInput(), LINKS.classes$SNAM), CONCEPTS.ClassDefinition$NR))) {
      tgs.indent();
      tgs.append("TYPE_");
      tgs.append(SPropertyOperations.getString(c, PROPS.name$MnvL));
      tgs.newLine();
    }
    ctx.getBuffer().area().decreaseIndent();
    tgs.append("} lpTypes;");
    tgs.newLine();
    tgs.newLine();

    // reverse handler
    if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("pcs")) {
      tgs.append("void reverse(struct lp_state_type * s, tw_bf * bf, struct event_content_type *msg, tw_lp * lp)");
      tgs.newLine();
    } else {
      tgs.append("void reverse(struct phold_state* s, tw_bf* bf, struct phold_message *msg, tw_lp * lp)");
      tgs.newLine();
    }
    tgs.append("{");
    tgs.newLine();
    ctx.getBuffer().area().increaseIndent();
    tgs.indent();
    tgs.append("fflush(stdout);");
    tgs.newLine();
    tgs.indent();
    tgs.append("RESTORE_STATE(s, msg, lp);");
    tgs.newLine();
    ctx.getBuffer().area().decreaseIndent();
    tgs.append("}");
    tgs.newLine();
    tgs.newLine();

    // model_lps array
    tgs.append("tw_lptype model_lps[] = {");
    tgs.newLine();
    ctx.getBuffer().area().increaseIndent();
    for (SNode c : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(ctx.getPrimaryInput(), LINKS.classes$SNAM), CONCEPTS.ClassDefinition$NR))) {
      tgs.indent();
      tgs.append("{");
      tgs.newLine();
      tgs.indent();
      tgs.append("(init_f) ");
      tgs.append(SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL));
      tgs.append("_");
      tgs.append(SPropertyOperations.getString(c, PROPS.name$MnvL));
      tgs.append("_init,");
      tgs.newLine();
      // pre_run is not considered atm
      tgs.indent();
      tgs.append("(pre_run_f) NULL,");
      tgs.newLine();
      tgs.indent();
      tgs.append("(event_f) ");
      tgs.append(SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL));
      tgs.append("_");
      tgs.append(SPropertyOperations.getString(c, PROPS.name$MnvL));
      tgs.append("_event,");
      tgs.newLine();
      tgs.indent();
      tgs.append("(revent_f) reverse,");
      tgs.newLine();
      tgs.indent();
      tgs.append("(commit_f) NULL,");
      tgs.newLine();
      tgs.indent();
      tgs.append("(final_f) ");
      tgs.append(SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL));
      tgs.append("_");
      tgs.append(SPropertyOperations.getString(c, PROPS.name$MnvL));
      tgs.append("_final,");
      tgs.newLine();
      tgs.indent();
      tgs.append("(map_f) custom_mapping_lp_to_pe,");
      tgs.newLine();
      tgs.indent();
      tgs.append("sizeof(");
      tgs.appendNode(ITypeDeclaration__BehaviorDescriptor.createType_id3o2OLGv7CoR.invoke(SLinkOperations.getTarget(c, LINKS.stateStruct$NqNO)));
      tgs.append(")");
      tgs.newLine();
      tgs.indent();
      tgs.append("},");
      tgs.newLine();
    }
    tgs.indent();
    tgs.append("{ 0 },");
    tgs.newLine();
    ctx.getBuffer().area().decreaseIndent();
    tgs.append("};");
    tgs.newLine();
    tgs.newLine();

    // get the total number of LPs
    int lps = 0;
    for (SNode allocation : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(ctx.getPrimaryInput(), LINKS.processAllocations$cuUJ), CONCEPTS.ProcessAllocation$5Z))) {
      {
        final SNode interval = SLinkOperations.getTarget(allocation, LINKS.processes$hZqx);
        if (SNodeOperations.isInstanceOf(interval, CONCEPTS.ProcessArray$Ux)) {
          lps += (SPropertyOperations.getInteger(interval, PROPS.right$2uAQ) - SPropertyOperations.getInteger(interval, PROPS.left$2u8O) + 1);
        }
      }
      {
        final SNode sequence = SLinkOperations.getTarget(allocation, LINKS.processes$hZqx);
        if (SNodeOperations.isInstanceOf(sequence, CONCEPTS.ProcessSequence$B$)) {
          lps += ListSequence.fromList(SLinkOperations.getChildren(sequence, LINKS.processes$2JvY)).count();
        }
      }
    }

    // main function
    tgs.append("int main(int argc, char **argv)");
    tgs.newLine();
    tgs.append("{");
    tgs.newLine();
    ctx.getBuffer().area().increaseIndent();
    tgs.indent();
    tgs.append("tw_init(&argc, &argv);");
    tgs.newLine();
    tgs.newLine();

    StartupCode.startupCode(ctx.getPrimaryInput(), ctx);

    // todo generalize
    if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("pcs")) {
      tgs.indent();
      tgs.append("g_tw_ts_end = 600.0;");
      tgs.newLine();
      tgs.newLine();
    } else if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("phold")) {
      tgs.indent();
      tgs.append("g_tw_ts_end = 350.0;");
      tgs.newLine();
      tgs.newLine();
    } else {
      tgs.indent();
      tgs.append("g_tw_ts_end = 50000.0;");
      tgs.newLine();
      tgs.newLine();
    }

    tgs.indent();
    tgs.append("g_tw_mapping = CUSTOM;");
    tgs.newLine();
    tgs.indent();
    tgs.append("g_tw_custom_initial_mapping = &custom_mapping_setup;");
    tgs.newLine();
    tgs.indent();
    tgs.append("g_tw_custom_lp_global_to_local_map = &custom_mapping_lpgid_to_local;");
    tgs.newLine();
    tgs.newLine();

    tgs.indent();
    tgs.append("// define the number of LPs per PE");
    tgs.newLine();
    tgs.indent();
    tgs.append("g_tw_nlp = ");
    tgs.append(String.valueOf(lps));
    tgs.append(";");
    tgs.newLine();
    tgs.indent();
    tgs.append("unsigned int custom_lps_per_pe = g_tw_nlp/tw_nnodes();");
    tgs.newLine();
    tgs.indent();
    tgs.append("unsigned int leftover_lps = g_tw_nlp % tw_nnodes();");
    tgs.newLine();
    tgs.newLine();

    tgs.indent();
    tgs.append("if(g_tw_mynode == 0)\n          custom_lps_per_pe += leftover_lps;\n");
    tgs.newLine();

    tgs.indent();
    tgs.append("// set model_lps");
    tgs.newLine();
    tgs.indent();
    tgs.append("g_tw_lp_types = model_lps;");
    tgs.newLine();
    tgs.indent();
    tgs.append("tw_define_lps(custom_lps_per_pe, sizeof(");
    tgs.appendNode(ITypeDeclaration__BehaviorDescriptor.createType_id3o2OLGv7CoR.invoke(SLinkOperations.getTarget(ctx.getPrimaryInput(), LINKS.messageStruct$xVlJ)));
    tgs.append("));");
    tgs.newLine();
    tgs.newLine();

    tgs.indent();
    tgs.append("tw_lp_setup_types();");
    tgs.newLine();
    tgs.newLine();

    if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("pcs")) {
      tgs.indent();
      tgs.append("init_allocators(g_tw_nlp);");
      tgs.newLine();
    }

    tgs.indent();
    tgs.append("tw_run();");
    tgs.newLine();
    tgs.indent();
    tgs.append("tw_end();");
    tgs.newLine();
    tgs.newLine();

    if (SPropertyOperations.getString(ctx.getPrimaryInput(), PROPS.name$MnvL).contains("pcs")) {
      tgs.indent();
      tgs.append("destroy_allocators();");
      tgs.newLine();
      tgs.newLine();
    }

    tgs.indent();
    tgs.append("return 0;");
    tgs.newLine();

    ctx.getBuffer().area().decreaseIndent();
    tgs.append("}");
    tgs.newLine();




    if (tgs.needPositions()) {
      tgs.fillUnitInfo(UnitConcept__BehaviorDescriptor.getUnitName_id4pl5GY7LKmR.invoke(SNodeOperations.cast(ctx.getPrimaryInput(), CONCEPTS.UnitConcept$1g)));
    }
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink eventType$MGmZ = MetaAdapterFactory.getContainmentLink(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x2e66f9a613f69c80L, 0x2e66f9a613f69c82L, "eventType");
    /*package*/ static final SContainmentLink events$uflG = MetaAdapterFactory.getContainmentLink(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x1ada9a09174c9630L, 0x2dc3a69083753b9fL, "events");
    /*package*/ static final SContainmentLink processes$hZqx = MetaAdapterFactory.getContainmentLink(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x4117a694e6393783L, 0x4117a694e6393787L, "processes");
    /*package*/ static final SContainmentLink processAllocations$cuUJ = MetaAdapterFactory.getContainmentLink(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x1ada9a09174c9630L, 0x4117a694e6409a0eL, "processAllocations");
    /*package*/ static final SContainmentLink messageStruct$xVlJ = MetaAdapterFactory.getContainmentLink(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x1ada9a09174c9630L, 0x6de6339fa564bed8L, "messageStruct");
    /*package*/ static final SContainmentLink members$C59R = MetaAdapterFactory.getContainmentLink(0xefda956e491e4f00L, 0xba1436af2f213ecfL, 0x6285e27d4ff6c9f5L, 0x6285e27d4ff7db92L, "members");
    /*package*/ static final SContainmentLink type$sXU3 = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x46a2a92ac61b183L, 0x46a2a92ac61b184L, "type");
    /*package*/ static final SContainmentLink arguments$6da0 = MetaAdapterFactory.getContainmentLink(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x707ac195dd5d51f2L, 0x4f39f90935e92f45L, "arguments");
    /*package*/ static final SContainmentLink body$1GE0 = MetaAdapterFactory.getContainmentLink(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x595522006a5b97e1L, 0x3a16e3a9c7ad9954L, "body");
    /*package*/ static final SContainmentLink externalFunctions$LqEg = MetaAdapterFactory.getContainmentLink(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x1ada9a09174c9630L, 0x6f36cc77d0a2c4ceL, "externalFunctions");
    /*package*/ static final SContainmentLink handlers$Nr2P = MetaAdapterFactory.getContainmentLink(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x4117a694e5b8c1a0L, 0x4117a694e5b8c1a3L, "handlers");
    /*package*/ static final SContainmentLink function$5bPH = MetaAdapterFactory.getContainmentLink(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x2dc3a690836fd0d0L, 0x74d88000543a2a9fL, "function");
    /*package*/ static final SContainmentLink baseType$zMGV = MetaAdapterFactory.getContainmentLink(0xa9d696470840491eL, 0xbf392eb0805d2011L, 0x6bbcdccef5e46755L, 0x6bbcdccef5e46756L, "baseType");
    /*package*/ static final SContainmentLink stateStruct$NqNO = MetaAdapterFactory.getContainmentLink(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x4117a694e5b8c1a0L, 0x4117a694e5b8c1a2L, "stateStruct");
    /*package*/ static final SContainmentLink statements$euTV = MetaAdapterFactory.getContainmentLink(0xa9d696470840491eL, 0xbf392eb0805d2011L, 0x3a16e3a9c7ad9955L, 0x3a16e3a9c7ad9956L, "statements");
    /*package*/ static final SContainmentLink to$WtFs = MetaAdapterFactory.getContainmentLink(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x68458b9b5da4ec77L, 0x6f2af7ea6983412cL, "to");
    /*package*/ static final SReferenceLink arg$WIp5 = MetaAdapterFactory.getReferenceLink(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x1d0c3765e2e7d0baL, 0x1d0c3765e2e7d0bbL, "arg");
    /*package*/ static final SContainmentLink classes$SNAM = MetaAdapterFactory.getContainmentLink(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x1ada9a09174c9630L, 0x4117a694e5ba8536L, "classes");
    /*package*/ static final SContainmentLink processes$2JvY = MetaAdapterFactory.getContainmentLink(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x4117a694e64867a6L, 0x4117a694e64867a7L, "processes");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty right$2uAQ = MetaAdapterFactory.getProperty(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x4117a694e6486788L, 0x4117a694e648678cL, "right");
    /*package*/ static final SProperty left$2u8O = MetaAdapterFactory.getProperty(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x4117a694e6486788L, 0x4117a694e648678aL, "left");
    /*package*/ static final SProperty eventName$AHdn = MetaAdapterFactory.getProperty(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x2dc3a690836fd0d0L, 0x3aa70864b453eff1L, "eventName");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept EventDefinition$wO = MetaAdapterFactory.getConcept(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x2e66f9a613f69c80L, "DESL.structure.EventDefinition");
    /*package*/ static final SConcept ProcessArray$Ux = MetaAdapterFactory.getConcept(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x4117a694e6486788L, "DESL.structure.ProcessArray");
    /*package*/ static final SConcept ProcessAllocation$5Z = MetaAdapterFactory.getConcept(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x4117a694e6393783L, "DESL.structure.ProcessAllocation");
    /*package*/ static final SConcept RngType$1E = MetaAdapterFactory.getConcept(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x23bd070ad14172a2L, "DESL.structure.RngType");
    /*package*/ static final SConcept Random$XZ = MetaAdapterFactory.getConcept(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x2476b4949807b946L, "DESL.structure.Random");
    /*package*/ static final SConcept Expent$Yu = MetaAdapterFactory.getConcept(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x2476b4949807b947L, "DESL.structure.Expent");
    /*package*/ static final SConcept ExternalFunction$U_ = MetaAdapterFactory.getConcept(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x6f36cc77d0c6228bL, "DESL.structure.ExternalFunction");
    /*package*/ static final SConcept EventHandler$Ov = MetaAdapterFactory.getConcept(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x2dc3a690836fd0d0L, "DESL.structure.EventHandler");
    /*package*/ static final SConcept Argument$9m = MetaAdapterFactory.getConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x6d872ef9245a20d7L, "com.mbeddr.core.modules.structure.Argument");
    /*package*/ static final SConcept PointerType$HX = MetaAdapterFactory.getConcept(0x3bf5377ae9044dedL, 0x97545a516023bfaaL, 0x3e0cae5e366d630L, "com.mbeddr.core.pointers.structure.PointerType");
    /*package*/ static final SConcept SendEvent$u = MetaAdapterFactory.getConcept(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x68458b9b5da4ec77L, "DESL.structure.SendEvent");
    /*package*/ static final SConcept ArgumentRef$iE = MetaAdapterFactory.getConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x1d0c3765e2e7d0baL, "com.mbeddr.core.modules.structure.ArgumentRef");
    /*package*/ static final SConcept ClassDefinition$NR = MetaAdapterFactory.getConcept(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x4117a694e5b8c1a0L, "DESL.structure.ClassDefinition");
    /*package*/ static final SConcept ProcessSequence$B$ = MetaAdapterFactory.getConcept(0xc4765525912b41b9L, 0xace4ce3b88117666L, 0x4117a694e64867a6L, "DESL.structure.ProcessSequence");
    /*package*/ static final SInterfaceConcept UnitConcept$1g = MetaAdapterFactory.getInterfaceConcept(0x9ded098bad6a4657L, 0xbfd948636cfe8bc3L, 0x465516cf87c705a4L, "jetbrains.mps.lang.traceable.structure.UnitConcept");
  }
}
