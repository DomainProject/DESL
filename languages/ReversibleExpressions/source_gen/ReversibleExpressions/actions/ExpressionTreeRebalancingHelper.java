package ReversibleExpressions.actions;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import ReversibleExpressions.behavior.ReversibleExpression__BehaviorDescriptor;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class ExpressionTreeRebalancingHelper {

  /**
   * Performs a left rotation on the expression tree at the given node.
   * 
   * @param node the node where the roatation should be performed
   * @return true if the rotation was successful, false otherwise
   */
  private static boolean rotateLeft(SNode node) {
    SNode rightChild = SNodeOperations.cast(SLinkOperations.getTarget(node, LINKS.right$KPZS), CONCEPTS.BinaryExpression$b);
    // backSideExpression may be null at this point
    SNode newChild = SLinkOperations.getTarget(rightChild, LINKS.left$KPKR);
    if (newChild != null) {
      SNodeOperations.deleteNode(rightChild);
      SNodeOperations.replaceWithAnother(node, rightChild);
      SNodeOperations.replaceWithAnother(newChild, node);
      SLinkOperations.setTarget(node, LINKS.right$KPZS, newChild);
      return true;
    } else {
      return false;
    }
  }

  /**
   * Performs a right rotation on the expression tree at the given node.
   * 
   * @param node the node where the rotation should be performed
   * @return return true if the rotation was successful, false otherwise
   */
  private static boolean rotateRight(SNode node) {
    SNode child = SNodeOperations.cast(SLinkOperations.getTarget(node, LINKS.left$KPKR), CONCEPTS.BinaryExpression$b);
    // backSideExpression may be null at this point
    SNode newChild = SLinkOperations.getTarget(child, LINKS.right$KPZS);
    if (newChild != null) {
      SNodeOperations.deleteNode(child);
      SNodeOperations.replaceWithAnother(node, child);
      SNodeOperations.replaceWithAnother(newChild, node);
      SLinkOperations.setTarget(node, LINKS.left$KPKR, newChild);
      return true;
    } else {
      return false;
    }
  }

  /**
   * Checks whether the priority is correct in the expression tree within the given child-parent node.
   * isRight indicates if child is the right child of parent.
   * The expression tree needs to be rotated, if either one of the two conditions hold
   * (1) the child node's priority is smaller than of the parent's
   * (2) they have the same priorities but the child is a right child (and we want to have left derivation)
   */
  private static boolean isBadPriority(SNode parent, SNode child, boolean isRight) {
    int childPriority = (int) ReversibleExpression__BehaviorDescriptor.getPriolevel_id5HxjapwgqKu.invoke(SNodeOperations.asSConcept(SNodeOperations.getConcept(child)));
    int parentPriority = (int) ReversibleExpression__BehaviorDescriptor.getPriolevel_id5HxjapwgqKu.invoke(SNodeOperations.asSConcept(SNodeOperations.getConcept(parent)));
    return childPriority < parentPriority || (isRight && childPriority == parentPriority);
  }

  /**
   * Rebalances the subtree of the given expression.
   * Only binary expressions are considered for rebalancing.
   * 
   * @param expression the expression which will be the root of the rebalancing
   */
  public static void demandRebalanceSubtree(SNode expression) {
    List<SNode> candidates = new ArrayList<SNode>();
    ListSequence.fromList(candidates).addElement(expression);

    while (ListSequence.fromList(candidates).isNotEmpty()) {
      SNode head = ListSequence.fromList(candidates).first();
      if (checkChildPriority(head, false, candidates) && checkChildPriority(head, true, candidates) && checkParentPriority(head, candidates)) {
        ListSequence.fromList(candidates).removeElementAt(0);
      }
    }
  }

  /**
   * Rebalances the whole expression tree of the given expression.
   * This means that the rebalancing will take place on the subtree
   * of the root of the tree where expression is present.
   * Only binary expressions are considered for rebalancing.
   * 
   * @param expression the expression in the tree
   */
  public static void demandRebalanceTree(SNode expression) {
    SNode act = expression;
    while (SNodeOperations.getParent(act) != null && SNodeOperations.isInstanceOf(SNodeOperations.getParent(act), CONCEPTS.ReversibleExpression$Zd)) {
      act = SNodeOperations.cast(SNodeOperations.getParent(act), CONCEPTS.ReversibleExpression$Zd);
    }

    List<SNode> candidates = new ArrayList<SNode>();
    ListSequence.fromList(candidates).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(act, CONCEPTS.BinaryExpression$b, true, new SAbstractConcept[]{})));

    while (ListSequence.fromList(candidates).isNotEmpty()) {
      SNode head = ListSequence.fromList(candidates).first();
      if (checkChildPriority(head, false, candidates) && checkChildPriority(head, true, candidates) && checkParentPriority(head, candidates)) {
        ListSequence.fromList(candidates).removeElementAt(0);
      }
    }
  }

  private static boolean checkChildPriority(SNode parent, boolean isRight, List<SNode> candidates) {
    SNode child = (isRight ? SLinkOperations.getTarget(parent, LINKS.right$KPZS) : SLinkOperations.getTarget(parent, LINKS.left$KPKR));
    if (SNodeOperations.isInstanceOf(child, CONCEPTS.BinaryExpression$b)) {
      if (isBadPriority(parent, SNodeOperations.cast(child, CONCEPTS.BinaryExpression$b), isRight)) {
        if (isRight) {
          rotateLeft(parent);
        } else {
          rotateRight(parent);
        }
        ListSequence.fromList(candidates).addElement(SNodeOperations.cast(child, CONCEPTS.BinaryExpression$b));
        return false;
      } else {
        return true;
      }
    } else if (SNodeOperations.isInstanceOf(child, CONCEPTS.TernaryExpression$WV)) {
      SNodeOperations.replaceWithAnother(parent, child);
      if (isRight) {
        SLinkOperations.setTarget(parent, LINKS.right$KPZS, SLinkOperations.getTarget(SNodeOperations.cast(child, CONCEPTS.TernaryExpression$WV), LINKS.condition$7cCn));
        SLinkOperations.setTarget(SNodeOperations.cast(child, CONCEPTS.TernaryExpression$WV), LINKS.condition$7cCn, parent);
      } else {
        SLinkOperations.setTarget(parent, LINKS.left$KPKR, SLinkOperations.getTarget(SNodeOperations.cast(child, CONCEPTS.TernaryExpression$WV), LINKS.elseExpr$7d6p));
        SLinkOperations.setTarget(SNodeOperations.cast(child, CONCEPTS.TernaryExpression$WV), LINKS.elseExpr$7d6p, parent);
      }

      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$b)) {
        ListSequence.fromList(candidates).addElement(SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$b));
      }

      return false;
    } else {
      return true;
    }
  }

  private static boolean checkParentPriority(SNode child, List<SNode> candidates) {
    if (SNodeOperations.getParent(child) == null) {
      return true;
    } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$b)) {
      boolean isRight = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$b), LINKS.right$KPZS) == child;
      if (isBadPriority(SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$b), child, isRight)) {
        if (isRight) {
          rotateLeft(SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$b));
        } else {
          rotateRight(SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$b));
        }
        return false;
      }
      return true;
    } else {
      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(child), CONCEPTS.UnaryPrePosModificationExpression$3r) || SNodeOperations.isInstanceOf(SNodeOperations.getParent(child), CONCEPTS.NotExpression$cZ)) {
        SNode unaryExpression = SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.UnaryExpression$91);
        SLinkOperations.setTarget(unaryExpression, LINKS.expression$HKAI, SLinkOperations.getTarget(child, LINKS.left$KPKR));
        SNodeOperations.replaceWithAnother(unaryExpression, child);
        SLinkOperations.setTarget(child, LINKS.left$KPKR, unaryExpression);
        return false;
      }
      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(child), CONCEPTS.GenericDotExpression$ia)) {
        SNode dotExpression = SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.GenericDotExpression$ia);
        SLinkOperations.setTarget(dotExpression, LINKS.expression$HKAI, SLinkOperations.getTarget(child, LINKS.right$KPZS));
        SNodeOperations.replaceWithAnother(dotExpression, child);
        SLinkOperations.setTarget(child, LINKS.right$KPZS, dotExpression);
        return false;
      }
      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(child), CONCEPTS.CastExpression$s_)) {
        SNode castExpression = SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.CastExpression$fT);
        SLinkOperations.setTarget(castExpression, LINKS.expr$VQmo, SLinkOperations.getTarget(child, LINKS.left$KPKR));
        SNodeOperations.replaceWithAnother(castExpression, child);
        SLinkOperations.setTarget(child, LINKS.left$KPKR, castExpression);
        return false;
      }

      return true;
    }
  }

  /**
   * Returns the first binary expression where the given expression is on the given side.
   * 
   * @param expression the descendant expression
   * @param isRight true - if the expression should be on the right, false - if the expression should be on the left
   * @return the found binary expression
   */
  public static SNode getBinaryExpression(SNode expression, boolean isRight) {
    if (!(SNodeOperations.isInstanceOf(SNodeOperations.getParent(expression), CONCEPTS.BinaryExpression$b))) {
      return null;
    } else {
      if ((isRight && SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(expression), CONCEPTS.BinaryExpression$b), LINKS.right$KPZS) == expression) || (!(isRight) && SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(expression), CONCEPTS.BinaryExpression$b), LINKS.left$KPKR) == expression)) {
        return SNodeOperations.cast(SNodeOperations.getParent(expression), CONCEPTS.BinaryExpression$b);
      } else {
        return getBinaryExpression(SNodeOperations.cast(SNodeOperations.getParent(expression), CONCEPTS.BinaryExpression$b), isRight);
      }
    }
  }

  public static void shuffleUnaryExpression(SNode child) {
    SNode p = SNodeOperations.getParent(child);
    if (SNodeOperations.isInstanceOf(p, CONCEPTS.UnaryExpression$91)) {
      boolean isReshuffle = SNodeOperations.isInstanceOf(p, CONCEPTS.IStopReshuffling$hp);
      if (!(isReshuffle) || (isReshuffle && SNodeOperations.hasRole(child, LINKS.expression$HKAI))) {
        SNode parent = SNodeOperations.cast(p, CONCEPTS.UnaryExpression$91);
        int ppl = (int) ReversibleExpression__BehaviorDescriptor.getPriolevel_id5HxjapwgqKu.invoke(SNodeOperations.asSConcept(SNodeOperations.getConcept(parent)));
        int cpl = (int) ReversibleExpression__BehaviorDescriptor.getPriolevel_id5HxjapwgqKu.invoke(SNodeOperations.asSConcept(SNodeOperations.getConcept(child)));
        if (ppl > cpl) {
          SNode childExpression = SLinkOperations.getTarget(child, LINKS.expression$HKAI);
          SNodeOperations.deleteNode(child);
          SNodeOperations.replaceWithAnother(parent, child);
          SLinkOperations.setTarget(child, LINKS.expression$HKAI, parent);
          SLinkOperations.setTarget(parent, LINKS.expression$HKAI, childExpression);
          shuffleUnaryExpression(child);
        }
      }
    }
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink right$KPZS = MetaAdapterFactory.getContainmentLink(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x7af69e2e83a1ba34L, 0x7af69e2e83a1ba41L, "right");
    /*package*/ static final SContainmentLink left$KPKR = MetaAdapterFactory.getContainmentLink(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x7af69e2e83a1ba34L, 0x7af69e2e83a1ba40L, "left");
    /*package*/ static final SContainmentLink condition$7cCn = MetaAdapterFactory.getContainmentLink(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x79253aa36e3393aeL, 0x79253aa36e3393afL, "condition");
    /*package*/ static final SContainmentLink elseExpr$7d6p = MetaAdapterFactory.getContainmentLink(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x79253aa36e3393aeL, 0x79253aa36e3393b1L, "elseExpr");
    /*package*/ static final SContainmentLink expression$HKAI = MetaAdapterFactory.getContainmentLink(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x29b5b7c4a3763232L, 0x64ae61a4018a9c50L, "expression");
    /*package*/ static final SContainmentLink expr$VQmo = MetaAdapterFactory.getContainmentLink(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x5bbe8a6d239d0b54L, 0x5bbe8a6d239d0b56L, "expr");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept BinaryExpression$b = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x7af69e2e83a1ba34L, "ReversibleExpressions.structure.BinaryExpression");
    /*package*/ static final SConcept ReversibleExpression$Zd = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x7af69e2e83a1ba32L, "ReversibleExpressions.structure.ReversibleExpression");
    /*package*/ static final SConcept TernaryExpression$WV = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x79253aa36e3393aeL, "ReversibleExpressions.structure.TernaryExpression");
    /*package*/ static final SConcept UnaryExpression$91 = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x29b5b7c4a3763232L, "ReversibleExpressions.structure.UnaryExpression");
    /*package*/ static final SConcept UnaryPrePosModificationExpression$3r = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x632cdd5acfb8529eL, "ReversibleExpressions.structure.UnaryPrePosModificationExpression");
    /*package*/ static final SConcept NotExpression$cZ = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x352a4cc97cbac907L, "ReversibleExpressions.structure.NotExpression");
    /*package*/ static final SConcept GenericDotExpression$ia = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x401df715da462c0cL, "ReversibleExpressions.structure.GenericDotExpression");
    /*package*/ static final SConcept CastExpression$fT = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x5bbe8a6d239d0b54L, "ReversibleExpressions.structure.CastExpression");
    /*package*/ static final SConcept CastExpression$s_ = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x5bbe8a6d239d0b54L, "com.mbeddr.core.expressions.structure.CastExpression");
    /*package*/ static final SInterfaceConcept IStopReshuffling$hp = MetaAdapterFactory.getInterfaceConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7a080c0a8c1380ceL, "com.mbeddr.core.expressions.structure.IStopReshuffling");
  }
}
