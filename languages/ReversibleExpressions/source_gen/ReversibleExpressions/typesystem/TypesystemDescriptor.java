package ReversibleExpressions.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.BaseHelginsDescriptor;
import jetbrains.mps.lang.typesystem.runtime.InferenceRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.ComparisonRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.OverloadedOperationsTypesProvider;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.SubtypingManager;
import jetbrains.mps.errors.IRuleConflictWarningProducer;
import ReversibleExpressions.behavior.ReversibleExpression__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import ReversibleExpressions.behavior.NumberEvaluationHelper;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class TypesystemDescriptor extends BaseHelginsDescriptor {
  public TypesystemDescriptor() {
    {
      InferenceRule_Runtime inferenceRule = new typeof_AssignmentExpr_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_BinaryEqualityComparisonExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_BinaryExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_BinaryNumberLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_BinaryOrderedComparisonExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_BitwiseNotExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_BooleanLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_CastExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_CharLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_CommentedContent_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ExpressionList_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_GenericDotExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_GenericMemberRef_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_GlobalConstantRef_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_GlobalVarRef_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_HexNumberLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_NotExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_NullExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_NumberLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_OctalNumberLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ParensExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ReversibleFunctionCall_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ScientificNumber_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_StaticValueExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_UnaryArithmeticExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_UnaryMinusExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_VaArgExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_VaList_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ArrayAccessExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_AssignmentExpr_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_BinaryComparisonExpressionSigned_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_BitwiseNotExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_DirectAssignmentExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_DivExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ExpressionList_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_INumericLiteral_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_IVariableDeclaration_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ReversibleFunctionCall_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_UnaryMinusExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_UnaryPrePosModificationExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_numberLiteral_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new unbalancedBinaryExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      ComparisonRule_Runtime comparisonRule = new compareMeetTypeWithMeetType_ComparisonRule();
      this.myComparisonRules.add(comparisonRule);
    }
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_e(CONCEPTS.BinaryComparisonExpression$fF));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.BitwiseAndExpression$x7));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.BitwiseLeftShiftExpression$z_));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.BitwiseORExpression$iY));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.BitwiseRightShiftExpression$4z));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.BitwiseXORExpression$4L));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.ModuloExpression$5u));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_c(CONCEPTS.DirectDivAssignmentExpression$me));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_c(CONCEPTS.DirectMinusAssignmentExpression$JM));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_c(CONCEPTS.DirectMultiAssignmentExpression$KK));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_c(CONCEPTS.DirectPlusAssignmentExpression$O_));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.DirectBitwiseANDAssignmentExpression$85));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.DirectBitwiseLeftShiftAssignmentExpression$69));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.DirectBitwiseORAssignmentExpression$kc));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.DirectBitwiseRightShiftExpression$77));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.DirectBitwiseXORAssignmentExpression$93));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.DirectModuloAssignmentExpression$5b));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a(CONCEPTS.BinaryLogicalExpression$D0));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a_0(CONCEPTS.DivExpression$K5));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a_0(CONCEPTS.MinusExpression$zY));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a_0(CONCEPTS.MultiExpression$J7));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a_0(CONCEPTS.PlusExpression$xz));
  }
  public static class CustomOverloadedOperationsTypesProvider_e extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_e(SAbstractConcept concept) {
      this.myLeftOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept"));
      this.myRightOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept"));
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:a08f1c59-09f4-4839-91dc-89de02b086a5(ReversibleExpressions.typesystem)";
      this.myRuleNodeId = "1664480272136308574";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba3aL, "com.mbeddr.core.expressions.structure.BooleanType"));
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if (AssignableSuperTypeHelper.hasComparableSuperTypes(leftOperandType, rightOperandType)) {
        return true;
      }
      return false;
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_b extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_b(SAbstractConcept concept) {
      this.myLeftOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myRightOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:a08f1c59-09f4-4839-91dc-89de02b086a5(ReversibleExpressions.typesystem)";
      this.myRuleNodeId = "3342324201519061667";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if ((boolean) ReversibleExpression__BehaviorDescriptor.isStaticallyEvaluatable_id3ilck8Kr3zN.invoke(SNodeOperations.cast(operation, CONCEPTS.BinaryExpression$b))) {
        return NumberEvaluationHelper.staticType(leftOperandType, rightOperandType, SNodeOperations.cast(operation, CONCEPTS.BinaryExpression$b));
      }

      // Check if both operants have the same type
      if (Objects.equals(SNodeOperations.getConcept(leftOperandType), SNodeOperations.getConcept(rightOperandType))) {
        return leftOperandType;
      }

      SNode commenSuperType = AssignableSuperTypeHelper.getCommonSuperType(leftOperandType, rightOperandType);
      return commenSuperType;
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      // Why is the left and right operand type not importend when "is applicable" = true?
      // I think the "is applicalbe" overrides the operand check
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.INumber$C8)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.INumber$C8)) {
          return true;
        }
      }
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(leftOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.INumber$C8)) {
          return true;
        }
      }
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.INumber$C8)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(rightOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
          return true;
        }
      }
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(leftOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(rightOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
          return true;
        }
      }
      return false;
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_c extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_c(SAbstractConcept concept) {
      this.myLeftOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myRightOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:a08f1c59-09f4-4839-91dc-89de02b086a5(ReversibleExpressions.typesystem)";
      this.myRuleNodeId = "3820836583575319966";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if ((boolean) ReversibleExpression__BehaviorDescriptor.isStaticallyEvaluatable_id3ilck8Kr3zN.invoke(operation)) {
        return NumberEvaluationHelper.staticType(leftOperandType, rightOperandType, operation);
      }

      // Check if both operants have the same type
      if (Objects.equals(SNodeOperations.getConcept(leftOperandType), SNodeOperations.getConcept(rightOperandType))) {
        return leftOperandType;
      }

      // Calculate all supertypes from the right operant and check if the "near" supertype equal to the
      // type of the left operantcon
      SNode superType = AssignableSuperTypeHelper.getAssignableSuperType(leftOperandType, rightOperandType);
      if (superType != null) {
        return superType;
      }

      return null;
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return TypeChecker.getInstance().getSubtypingManager().isSubtype(rightOperandType, leftOperandType);
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_d extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_d(SAbstractConcept concept) {
      this.myLeftOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myRightOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:a08f1c59-09f4-4839-91dc-89de02b086a5(ReversibleExpressions.typesystem)";
      this.myRuleNodeId = "7193082937527768554";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if ((boolean) ReversibleExpression__BehaviorDescriptor.isStaticallyEvaluatable_id3ilck8Kr3zN.invoke(operation)) {
        return NumberEvaluationHelper.staticType(leftOperandType, rightOperandType, operation);
      }

      // Check if both operants have the same type
      if (Objects.equals(SNodeOperations.getConcept(leftOperandType), SNodeOperations.getConcept(rightOperandType))) {
        return leftOperandType;
      }

      // Calculate all supertypes from the right operant and check if the "near" supertype equal to the
      // type of the left operantcon
      SNode superType = AssignableSuperTypeHelper.getAssignableSuperType(leftOperandType, rightOperandType);
      if (superType != null) {
        return superType;
      }

      return null;
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      // Why is the left and right operand type not importend when "is applicable" = true?
      // I think the "is applicalbe" overrides the operand check
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.INumber$C8)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.INumber$C8)) {
          return true;
        }
      }
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(leftOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.INumber$C8)) {
          return true;
        }
      }
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.INumber$C8)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(rightOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
          return true;
        }
      }
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(leftOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(rightOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
          return true;
        }
      }

      return false;
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_a extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_a(SAbstractConcept concept) {
      this.myLeftOperandType = createBooleanType_3ist9o_a0a0a5();
      this.myRightOperandType = createBooleanType_3ist9o_a0b0a5();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:a08f1c59-09f4-4839-91dc-89de02b086a5(ReversibleExpressions.typesystem)";
      this.myRuleNodeId = "8399455261460730077";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createBooleanType_3ist9o_a0a1f();
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createBooleanType_3ist9o_a0a0a5() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$fL);
      return n0.getResult();
    }
    private static SNode createBooleanType_3ist9o_a0b0a5() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$fL);
      return n0.getResult();
    }
    private static SNode createBooleanType_3ist9o_a0a1f() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$fL);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_a_0 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_a_0(SAbstractConcept concept) {
      this.myLeftOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myRightOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:a08f1c59-09f4-4839-91dc-89de02b086a5(ReversibleExpressions.typesystem)";
      this.myRuleNodeId = "8864856114140206253";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {

      // Check if both operants have the same type
      if (Objects.equals(SNodeOperations.getConcept(leftOperandType), SNodeOperations.getConcept(rightOperandType))) {
        return leftOperandType;
      }
      SNode commenSuperType = AssignableSuperTypeHelper.getCommonSuperType(leftOperandType, rightOperandType);
      return commenSuperType;
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept BinaryComparisonExpression$fF = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x7af69e2e83a1ba3fL, "ReversibleExpressions.structure.BinaryComparisonExpression");
    /*package*/ static final SConcept BitwiseAndExpression$x7 = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x52bff1066a5caaafL, "ReversibleExpressions.structure.BitwiseAndExpression");
    /*package*/ static final SConcept BitwiseLeftShiftExpression$z_ = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x7d15ed3ba56cbdbfL, "ReversibleExpressions.structure.BitwiseLeftShiftExpression");
    /*package*/ static final SConcept BitwiseORExpression$iY = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0xfc5c413252eabc7L, "ReversibleExpressions.structure.BitwiseORExpression");
    /*package*/ static final SConcept BitwiseRightShiftExpression$4z = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x7d15ed3ba569dd50L, "ReversibleExpressions.structure.BitwiseRightShiftExpression");
    /*package*/ static final SConcept BitwiseXORExpression$4L = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x7d15ed3ba56988f4L, "ReversibleExpressions.structure.BitwiseXORExpression");
    /*package*/ static final SConcept ModuloExpression$5u = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x26d9c9de7721b2b0L, "ReversibleExpressions.structure.ModuloExpression");
    /*package*/ static final SConcept DirectDivAssignmentExpression$me = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x3b4cdae3e3167374L, "ReversibleExpressions.structure.DirectDivAssignmentExpression");
    /*package*/ static final SConcept DirectMinusAssignmentExpression$JM = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x3b4cdae3e316735aL, "ReversibleExpressions.structure.DirectMinusAssignmentExpression");
    /*package*/ static final SConcept DirectMultiAssignmentExpression$KK = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x3b4cdae3e316735cL, "ReversibleExpressions.structure.DirectMultiAssignmentExpression");
    /*package*/ static final SConcept DirectPlusAssignmentExpression$O_ = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x350656a10cd18bccL, "ReversibleExpressions.structure.DirectPlusAssignmentExpression");
    /*package*/ static final SConcept DirectBitwiseANDAssignmentExpression$85 = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x63d2f6d2334415d9L, "ReversibleExpressions.structure.DirectBitwiseANDAssignmentExpression");
    /*package*/ static final SConcept DirectBitwiseLeftShiftAssignmentExpression$69 = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x63d2f6d2334415d5L, "ReversibleExpressions.structure.DirectBitwiseLeftShiftAssignmentExpression");
    /*package*/ static final SConcept DirectBitwiseORAssignmentExpression$kc = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x63d2f6d2334415ddL, "ReversibleExpressions.structure.DirectBitwiseORAssignmentExpression");
    /*package*/ static final SConcept DirectBitwiseRightShiftExpression$77 = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x63d2f6d2334415d7L, "ReversibleExpressions.structure.DirectBitwiseRightShiftExpression");
    /*package*/ static final SConcept DirectBitwiseXORAssignmentExpression$93 = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x63d2f6d2334415dbL, "ReversibleExpressions.structure.DirectBitwiseXORAssignmentExpression");
    /*package*/ static final SConcept DirectModuloAssignmentExpression$5b = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x63d2f6d2334415d3L, "ReversibleExpressions.structure.DirectModuloAssignmentExpression");
    /*package*/ static final SConcept BinaryLogicalExpression$D0 = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x7490dc0ede26e046L, "ReversibleExpressions.structure.BinaryLogicalExpression");
    /*package*/ static final SConcept DivExpression$K5 = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x4ffba68fe82b621eL, "ReversibleExpressions.structure.DivExpression");
    /*package*/ static final SConcept MinusExpression$zY = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x4ffba68fe82b621aL, "ReversibleExpressions.structure.MinusExpression");
    /*package*/ static final SConcept MultiExpression$J7 = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x4ffba68fe82b621cL, "ReversibleExpressions.structure.MultiExpression");
    /*package*/ static final SConcept PlusExpression$xz = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x4ffba68fe82b6215L, "ReversibleExpressions.structure.PlusExpression");
    /*package*/ static final SConcept BinaryExpression$b = MetaAdapterFactory.getConcept(0x9abffa92487542bfL, 0x9379c4f95eb496d4L, 0x7af69e2e83a1ba34L, "ReversibleExpressions.structure.BinaryExpression");
    /*package*/ static final SInterfaceConcept INumber$C8 = MetaAdapterFactory.getInterfaceConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b6206L, "com.mbeddr.core.expressions.structure.INumber");
    /*package*/ static final SConcept MeetType$ZG = MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x114b68ad132L, "jetbrains.mps.lang.typesystem.structure.MeetType");
    /*package*/ static final SConcept BooleanType$fL = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba3aL, "com.mbeddr.core.expressions.structure.BooleanType");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink argument$r2cT = MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x114b68ad132L, 0x114b68b040bL, "argument");
  }
}
